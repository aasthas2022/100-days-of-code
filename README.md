# 100DaysOfCode - Aastha Shukla

## Day 1 :

As I embark on my journey of #100DaysOfCode, I began by acquainting myself with AWS IAM Roles. Alongside, I've started tackling some of the easier LeetCode problems, setting the stage for a gradual and systematic understanding of various coding concepts and practices. Today's dive involved problem-solving in both JavaScript and SQL, promising an enriching learning journey ahead.

### JavaScript Solutions

- **[Return Length of Arguments Passed (LeetCode 2703)](https://leetcode.com/problems/return-length-of-arguments-passed/)**: This problem is a good starter to understand JavaScript's ability to manage variable numbers of arguments. The solution involved the creation and testing of the `argumentsLength` function with different argument sets.

- **[Concatenation of Array (LeetCode 1929)](https://leetcode.com/problems/concatenation-of-array/)**: A beginner-friendly problem, I tackled this with three distinct approaches for array concatenation - utilizing spread syntax, the `concat` function, and `push()`. This served as an excellent opportunity to get comfortable with basic array manipulations in JavaScript.

### SQL Learning

- **[Recyclable and Low Fat Products (LeetCode 1757)](https://leetcode.com/problems/recyclable-and-low-fat-products/)**: This SQL task helped me understand how to query data based on specific conditions (`low_fats = 'Y' AND recyclable = 'Y'`). It also opened the door to understanding why SQL opts for a single equals sign (=) for equality.


## Day 2 :

On the second day of my #100DaysOfCode journey, I delved deeper into JavaScript Promises and tried my hands on various techniques of array manipulation. An exciting new development today was that for the first time ever, I started uploading my solutions on LeetCode, to share my learning and approaches with the broader coding community.

### JavaScript Solutions

- **[Add Two Promises (LeetCode 2723)](https://leetcode.com/problems/add-two-promises/)**: This problem was an excellent exploration into Promise handling in JavaScript. I developed three distinct methods to handle and add the results of two promises - chaining promises using `then()`, using `allSettled()` to wait until all promises have either been fulfilled or rejected, and using `all()` to execute once all promises have been fulfilled. For the first time ever, I shared my solution on LeetCode, which you can find [here](https://leetcode.com/problems/add-two-promises/solutions/3751725/2723-add-two-promises-3-approaches-to-solution-with-references/).

- **[Build Array from Permutation (LeetCode 1920)](https://leetcode.com/problems/build-array-from-permutation/)**: This problem allowed me to experiment with multiple ways of array manipulation in JavaScript. I started with a basic `for` loop and `push()` method, and then moved on to more specific array manipulations techniques like `map()`, `from()`, `forEach()`, and `reduce()`. This exercise helped me better understand how these methods work and how to select the most suitable one based on the problem at hand. I also added this solution to LeetCode [here](https://leetcode.com/problems/build-array-from-permutation/solutions/3751712/build-array-from-permutation-7-approaches-to-solution/).

Key takeaways from today's learning journey are:

- Promises in JavaScript provide robust tools for handling asynchronous code execution, with different methods suited to different needs.
- Understanding the nuances of array manipulation techniques in JavaScript is vital. Each method has its strengths and selecting the right one can greatly enhance the efficiency of the solution.
- Uploading my solutions to LeetCode for the first time was a thrilling experience. It not only helps me reinforce my learning, but it also allows me to contribute to the coding community.

## Day 3 :

Today, I expanded my JavaScript problem-solving prowess by tackling more LeetCode problems. I focused on some well-known problems and leveraged several different approaches for each, enhancing my understanding of both the problem and the various ways to approach it.

### JavaScript Solutions

- **[Two Sum (LeetCode 1)](https://leetcode.com/problems/two-sum/)**: This problem is a classic and forms the basis of many algorithmic questions. I solved this problem using three different approaches. The first was a brute force approach with two for loops, the second was a slightly optimized version of the first approach, and the third used the array's `some()` method. This allowed me to understand and compare different methods, gaining a deep understanding of their efficiencies and differences. Check out my solutions [here](https://leetcode.com/problems/two-sum/solutions/3756452/1-3-easy-to-understand-approaches-for-beginners-javascript/).

- **[Palindrome Number (LeetCode 9)](https://leetcode.com/problems/palindrome-number/)**: Solving this problem was an exciting dive into checking if a number is a palindrome in JavaScript. I worked through six different approaches - using reversing logic by converting int to string, `every()` method, `for` loop, `while` loop, `reduce()` method, and recursion. Each method highlighted a different aspect of JavaScript, contributing to my overall understanding of the language. You can view my solutions [here](https://leetcode.com/problems/palindrome-number/solutions/3756537/6-beginner-friendly-javascript-approaches/).

Key takeaways from today's learning journey are:

- The `some()` method in JavaScript is a powerful function that can greatly simplify the process of finding elements in an array. Its ability to stop execution as soon as it finds a satisfying element can be leveraged to enhance efficiency.
- The `every()` method, in contrast, is used when all elements in an array need to satisfy a condition. This was very useful in checking if a number is a palindrome.
- Recursion can be a very effective method for solving problems, especially those that involve repetition of a process. Using recursion to solve the palindrome problem was an enriching experience, providing an insight into the utility of recursive solutions.
- The use of different loops (`for`, `while`) and the `reduce()` function showcased how different JavaScript features can be used to solve the same problem. Understanding these differences is essential for selecting the most efficient solution for a particular problem.
